import type {
  Adapter,
  GenerousOption as Opt,
  FlagDeclaration,
  Identify,
} from 'flags';
import { createClient } from '@vercel/edge-config';
import {
  VercelEdgeConfigInitDataProvider,
  type CreateOptions,
} from 'hypertune';

type FlagDefinition = {
  description?: string;
  options?: Array<{ value: unknown; label: string }>;
  origin?: string;
};

interface CreateSourceOptions extends CreateOptions {
  token: string;
  initDataProvider?: VercelEdgeConfigInitDataProvider;
}

type AdapterArgs<
  TFlagValues extends Record<string, unknown>,
  TContext extends Record<string, unknown>,
> = {
  createSource: (options: CreateSourceOptions) => {
    initIfNeeded: () => Promise<void>;
    root: (args: { args: { context: TContext } }) => {
      [K in keyof TFlagValues]: (args: {
        fallback: TFlagValues[K];
      }) => TFlagValues[K];
    };
  };
  flagFallbacks: TFlagValues;
  flagDefinitions: Record<keyof TFlagValues, FlagDefinition>;
  identify: Identify<TContext>;
  createSourceOptions?: CreateOptions;
};

/**
 * Creates the hypertune adapter from code generated by `npx hypertune`
 *
 * @example
 * ```ts
 * import {
 *   createSource,
 *   flagFallbacks,
 *   vercelFlagDefinitions,
 *   type Context,
 *   type TopLevelFlagValues,
 * } from './generated/hypertune'
 * import { createHypertuneAdapter } from '@flags-sdk/hypertune'
 * import { identify } from './lib/identify'
 *
 * const hypertuneAdapter = createHypertuneAdapter<TopLevelFlagValues, Context>({
 *   identify,
 *   createSource,
 *   flagFallbacks,
 *   flagDefinitions: vercelFlagDefinitions,
 * })
 *
 * export const showSummerBannerFlag = flag(
 *   hypertuneAdapter.declarations.summerSale
 * )
 * ```
 */
export const createHypertuneAdapter = <
  TFlagValues extends Record<string, unknown>,
  TContext extends Record<string, unknown>,
>({
  createSource,
  flagFallbacks,
  flagDefinitions,
  identify,
  createSourceOptions,
}: AdapterArgs<TFlagValues, TContext>) => {
  const token = (process.env.NEXT_PUBLIC_HYPERTUNE_TOKEN ??
    process.env.HYPERTUNE_TOKEN) as string;

  const hasEdgeConfig =
    createSourceOptions?.initDataProvider ??
    Boolean(
      process.env.EXPERIMENTATION_CONFIG &&
        process.env.EXPERIMENTATION_CONFIG_ITEM_KEY,
    );
  let adapterSource: ReturnType<typeof createSource> | undefined;

  const getSource = (): ReturnType<typeof createSource> => {
    if (!adapterSource) {
      const initDataProvider = hasEdgeConfig
        ? createSourceOptions?.initDataProvider ??
          new VercelEdgeConfigInitDataProvider({
            edgeConfigClient: createClient(
              process.env.EXPERIMENTATION_CONFIG as string,
            ),
            itemKey: process.env.EXPERIMENTATION_CONFIG_ITEM_KEY as string,
          })
        : undefined;
      adapterSource = createSource({
        ...createSourceOptions,
        token,
        initDataProvider: initDataProvider as VercelEdgeConfigInitDataProvider,
      });
    }
    return adapterSource;
  };

  const hypertuneAdapter = <K extends keyof TFlagValues>(
    key: K,
  ): Adapter<TFlagValues[K], TContext> => {
    return {
      origin: flagDefinitions[key].origin,
      async decide({ entities, defaultValue }) {
        if (!entities) {
          throw new Error(
            `identify() is required to produce Context for Hypertune flag ${String(
              key,
            )}`,
          );
        }
        if (typeof defaultValue === 'undefined') {
          throw new Error(
            `defaultValue is required for Hypertune flag ${String(key)}`,
          );
        }
        const source = getSource();
        await source.initIfNeeded();
        const hypertune = source.root({ args: { context: entities } });
        const method = hypertune[key] as (args: {
          fallback: TFlagValues[K];
        }) => TFlagValues[K];
        const result = method.call(hypertune, {
          fallback: defaultValue,
        });
        return result;
      },
    };
  };

  const createDeclaration = <K extends keyof TFlagValues>({
    key,
    options,
  }: {
    key: K;
    options?: Opt<TFlagValues[K]>[];
  }): FlagDeclaration<TFlagValues[K], TContext> => {
    const definition = flagDefinitions[key];
    const flagOptions = definition.options as Opt<TFlagValues[K]>[] | undefined;
    return {
      key: String(key),
      adapter: hypertuneAdapter(key),
      defaultValue: flagFallbacks[key],
      description: definition.description,
      options: options ?? flagOptions,
      identify,
    };
  };

  const declarations = new Proxy(
    Object.keys(flagDefinitions).reduce(
      (acc, key) => {
        acc[key] = createDeclaration({ key: key as keyof TFlagValues });
        return acc;
      },
      {} as Record<string, unknown>,
    ) as {
      [key in keyof TFlagValues]: FlagDeclaration<TFlagValues[key], TContext>;
    },
    {
      get(target, prop) {
        if (typeof prop === 'string' && !(prop in target)) {
          throw new Error(
            // biome-ignore lint/style/useTemplate: <explanation>
            `Attempted to access flag "${prop}" which is not found in the generated Hypertune code. ` +
              'Make sure it exists in the dashboard, and run `npx hypertune` to update your type-safe client.',
          );
        }
        return target[prop as keyof typeof target];
      },
    },
  );
  return { declarations, getSource };
};

/**
 * @deprecated Please use `createHypertuneAdapter()`
 */
export const hypertuneAdapter = createHypertuneAdapter;
